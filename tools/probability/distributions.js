// Math helpers
function factorial(n) { if (n <= 1) return 1; let r = 1; for (let i = 2; i <= n; i++) r *= i; return r; }
function binomial(n, k) { if (k > n) return 0; return factorial(n) / (factorial(k) * factorial(n - k)); }
function erf(x) { const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741, a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911; const sign = x < 0 ? -1 : 1; x = Math.abs(x); const t = 1 / (1 + p * x); return sign * (1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x)); }
function betaFn(a, b) { return gammaFn(a) * gammaFn(b) / gammaFn(a + b); }
function gammaFn(z) { if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gammaFn(1 - z)); z -= 1; const g = 7; const c = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7]; let x = c[0]; for (let i = 1; i < g + 2; i++) x += c[i] / (z + i); const t = z + g + 0.5; return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x; }
function lnGamma(z) { return Math.log(gammaFn(z)); }
function gammaSample(a) { if (a < 1) { return gammaSample(1 + a) * Math.pow(Math.random(), 1 / a); } const d = a - 1 / 3, c = 1 / Math.sqrt(9 * d); while (true) { let x, v; do { x = normalSample(); v = 1 + c * x; } while (v <= 0); v = v * v * v; const u = Math.random(); if (u < 1 - 0.0331 * (x * x) * (x * x)) return d * v; if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) return d * v; } }
function normalSample() { let u1 = Math.random(), u2 = Math.random(); return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2); }
function incBeta(x, a, b) { if (x <= 0) return 0; if (x >= 1) return 1; const bt = Math.exp(lnGamma(a + b) - lnGamma(a) - lnGamma(b) + a * Math.log(x) + b * Math.log(1 - x)); if (x < (a + 1) / (a + b + 2)) return bt * betaCF(x, a, b) / a; return 1 - bt * betaCF(1 - x, b, a) / b; }
function betaCF(x, a, b) { const maxIter = 100, eps = 3e-7; let qab = a + b, qap = a + 1, qam = a - 1; let c = 1, d = 1 - qab * x / qap; if (Math.abs(d) < 1e-30) d = 1e-30; d = 1 / d; let h = d; for (let m = 1; m <= maxIter; m++) { const m2 = 2 * m; let aa = m * (b - m) * x / ((qam + m2) * (a + m2)); d = 1 + aa * d; if (Math.abs(d) < 1e-30) d = 1e-30; c = 1 + aa / c; if (Math.abs(c) < 1e-30) c = 1e-30; d = 1 / d; h *= d * c; aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2)); d = 1 + aa * d; if (Math.abs(d) < 1e-30) d = 1e-30; c = 1 + aa / c; if (Math.abs(c) < 1e-30) c = 1e-30; d = 1 / d; const del = d * c; h *= del; if (Math.abs(del - 1) < eps) break; } return h; }
function incGamma(a, x) { if (x < 0 || a <= 0) return 0; if (x === 0) return 0; if (x < a + 1) { let sum = 1 / a, term = 1 / a; for (let n = 1; n < 100; n++) { term *= x / (a + n); sum += term; if (Math.abs(term) < 1e-10) break; } return sum * Math.exp(-x + a * Math.log(x) - lnGamma(a)); } let b = x + 1 - a, c = 1 / 1e-30, d = 1 / b, h = d; for (let i = 1; i < 100; i++) { const an = -i * (i - a); b += 2; d = an * d + b; if (Math.abs(d) < 1e-30) d = 1e-30; c = b + an / c; if (Math.abs(c) < 1e-30) c = 1e-30; d = 1 / d; const del = d * c; h *= del; if (Math.abs(del - 1) < 1e-10) break; } return 1 - Math.exp(-x + a * Math.log(x) - lnGamma(a)) * h; }

// Distribution Categories
const DIST_CATEGORIES = {
    'Continuous': ['normal', 'exponential', 'uniform', 'beta', 'gamma', 'lognormal', 'weibull', 'pareto', 'cauchy', 'laplace', 'logistic', 'gumbel', 'frechet', 'rayleigh', 'maxwell', 'chi', 'chisquared', 'studentt', 'f', 'triangular', 'pert', 'vonmises', 'semicircle', 'arcsine', 'kumaraswamy', 'levy', 'nakagami', 'rice', 'erlang', 'inversegamma', 'inversegaussian', 'lomax', 'dagum', 'burr', 'betaprime'],
    'Discrete': ['binomial', 'poisson', 'geometric', 'negativebinomial', 'hypergeometric', 'bernoulli', 'discreteuniform', 'zipf', 'logarithmic', 'skellam', 'borel', 'yulesimon', 'zeta'],
    'Special': ['halfnormal', 'foldednormal', 'truncatednormal', 'power', 'bradford', 'reciprocal', 'cosine', 'generalizedexponential']
};

const DISTRIBUTIONS = {
    normal: { name: 'Normal', category: 'Continuous', params: [{ id: 'mu', name: 'μ', min: -5, max: 5, step: 0.1, default: 0 }, { id: 'sigma', name: 'σ', min: 0.1, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=(1/σ√2π)e^(-(x-μ)²/2σ²)', pdf: (x, p) => Math.exp(-((x - p.mu) ** 2) / (2 * p.sigma ** 2)) / (p.sigma * Math.sqrt(2 * Math.PI)), cdf: (x, p) => 0.5 * (1 + erf((x - p.mu) / (p.sigma * Math.sqrt(2)))), mean: p => p.mu, variance: p => p.sigma ** 2, range: p => [p.mu - 4 * p.sigma, p.mu + 4 * p.sigma], sample: p => p.mu + p.sigma * normalSample() },
    exponential: { name: 'Exponential', category: 'Continuous', params: [{ id: 'lambda', name: 'λ', min: 0.1, max: 5, step: 0.1, default: 1 }], formula: 'f(x)=λe^(-λx)', pdf: (x, p) => x < 0 ? 0 : p.lambda * Math.exp(-p.lambda * x), cdf: (x, p) => x < 0 ? 0 : 1 - Math.exp(-p.lambda * x), mean: p => 1 / p.lambda, variance: p => 1 / (p.lambda ** 2), range: () => [0, 8], sample: p => -Math.log(Math.random()) / p.lambda },
    uniform: { name: 'Uniform', category: 'Continuous', params: [{ id: 'a', name: 'a', min: -5, max: 4, step: 0.5, default: 0 }, { id: 'b', name: 'b', min: -4, max: 10, step: 0.5, default: 5 }], formula: 'f(x)=1/(b-a)', pdf: (x, p) => (x >= p.a && x <= p.b) ? 1 / (p.b - p.a) : 0, cdf: (x, p) => x < p.a ? 0 : (x > p.b ? 1 : (x - p.a) / (p.b - p.a)), mean: p => (p.a + p.b) / 2, variance: p => ((p.b - p.a) ** 2) / 12, range: p => [p.a - 1, p.b + 1], sample: p => p.a + Math.random() * (p.b - p.a) },
    beta: { name: 'Beta', category: 'Continuous', params: [{ id: 'alpha', name: 'α', min: 0.1, max: 10, step: 0.1, default: 2 }, { id: 'beta', name: 'β', min: 0.1, max: 10, step: 0.1, default: 5 }], formula: 'f(x)=x^(α-1)(1-x)^(β-1)/B(α,β)', pdf: (x, p) => { if (x <= 0 || x >= 1) return 0; return (x ** (p.alpha - 1)) * ((1 - x) ** (p.beta - 1)) / betaFn(p.alpha, p.beta); }, cdf: (x, p) => incBeta(x, p.alpha, p.beta), mean: p => p.alpha / (p.alpha + p.beta), variance: p => (p.alpha * p.beta) / ((p.alpha + p.beta) ** 2 * (p.alpha + p.beta + 1)), range: () => [0, 1], sample: p => { let x = gammaSample(p.alpha), y = gammaSample(p.beta); return x / (x + y); } },
    gamma: { name: 'Gamma', category: 'Continuous', params: [{ id: 'k', name: 'k', min: 0.5, max: 10, step: 0.5, default: 2 }, { id: 'theta', name: 'θ', min: 0.5, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=x^(k-1)e^(-x/θ)/(θ^k Γ(k))', pdf: (x, p) => x <= 0 ? 0 : (x ** (p.k - 1)) * Math.exp(-x / p.theta) / ((p.theta ** p.k) * gammaFn(p.k)), cdf: (x, p) => x <= 0 ? 0 : incGamma(p.k, x / p.theta), mean: p => p.k * p.theta, variance: p => p.k * p.theta ** 2, range: p => [0, p.k * p.theta + 4 * Math.sqrt(p.k) * p.theta], sample: p => gammaSample(p.k) * p.theta },
    lognormal: { name: 'Log-Normal', category: 'Continuous', params: [{ id: 'mu', name: 'μ', min: -2, max: 2, step: 0.1, default: 0 }, { id: 'sigma', name: 'σ', min: 0.1, max: 2, step: 0.1, default: 0.5 }], formula: 'f(x)=(1/xσ√2π)e^(-(lnx-μ)²/2σ²)', pdf: (x, p) => x <= 0 ? 0 : Math.exp(-((Math.log(x) - p.mu) ** 2) / (2 * p.sigma ** 2)) / (x * p.sigma * Math.sqrt(2 * Math.PI)), cdf: (x, p) => x <= 0 ? 0 : 0.5 * (1 + erf((Math.log(x) - p.mu) / (p.sigma * Math.sqrt(2)))), mean: p => Math.exp(p.mu + p.sigma ** 2 / 2), variance: p => (Math.exp(p.sigma ** 2) - 1) * Math.exp(2 * p.mu + p.sigma ** 2), range: p => [0, Math.exp(p.mu + 3 * p.sigma)], sample: p => Math.exp(p.mu + p.sigma * normalSample()) },
    weibull: { name: 'Weibull', category: 'Continuous', params: [{ id: 'k', name: 'k', min: 0.5, max: 5, step: 0.1, default: 1.5 }, { id: 'lambda', name: 'λ', min: 0.5, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=(k/λ)(x/λ)^(k-1)e^(-(x/λ)^k)', pdf: (x, p) => x < 0 ? 0 : (p.k / p.lambda) * ((x / p.lambda) ** (p.k - 1)) * Math.exp(-((x / p.lambda) ** p.k)), cdf: (x, p) => x < 0 ? 0 : 1 - Math.exp(-((x / p.lambda) ** p.k)), mean: p => p.lambda * gammaFn(1 + 1 / p.k), variance: p => p.lambda ** 2 * (gammaFn(1 + 2 / p.k) - gammaFn(1 + 1 / p.k) ** 2), range: () => [0, 5], sample: p => p.lambda * (-Math.log(Math.random())) ** (1 / p.k) },
    pareto: { name: 'Pareto', category: 'Continuous', params: [{ id: 'xm', name: 'xₘ', min: 0.5, max: 3, step: 0.1, default: 1 }, { id: 'alpha', name: 'α', min: 1, max: 5, step: 0.1, default: 2 }], formula: 'f(x)=αxₘ^α/x^(α+1)', pdf: (x, p) => x < p.xm ? 0 : p.alpha * (p.xm ** p.alpha) / (x ** (p.alpha + 1)), cdf: (x, p) => x < p.xm ? 0 : 1 - (p.xm / x) ** p.alpha, mean: p => p.alpha <= 1 ? Infinity : p.alpha * p.xm / (p.alpha - 1), variance: p => p.alpha <= 2 ? Infinity : (p.xm ** 2) * p.alpha / ((p.alpha - 1) ** 2 * (p.alpha - 2)), range: p => [p.xm, p.xm * 5], sample: p => p.xm / (Math.random() ** (1 / p.alpha)) },
    cauchy: { name: 'Cauchy', category: 'Continuous', params: [{ id: 'x0', name: 'x₀', min: -3, max: 3, step: 0.1, default: 0 }, { id: 'gamma', name: 'γ', min: 0.1, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=1/(πγ(1+((x-x₀)/γ)²))', pdf: (x, p) => 1 / (Math.PI * p.gamma * (1 + ((x - p.x0) / p.gamma) ** 2)), cdf: (x, p) => 0.5 + Math.atan((x - p.x0) / p.gamma) / Math.PI, mean: () => NaN, variance: () => NaN, range: p => [p.x0 - 10, p.x0 + 10], sample: p => p.x0 + p.gamma * Math.tan(Math.PI * (Math.random() - 0.5)) },
    laplace: { name: 'Laplace', category: 'Continuous', params: [{ id: 'mu', name: 'μ', min: -3, max: 3, step: 0.1, default: 0 }, { id: 'b', name: 'b', min: 0.1, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=(1/2b)e^(-|x-μ|/b)', pdf: (x, p) => Math.exp(-Math.abs(x - p.mu) / p.b) / (2 * p.b), cdf: (x, p) => x < p.mu ? 0.5 * Math.exp((x - p.mu) / p.b) : 1 - 0.5 * Math.exp(-(x - p.mu) / p.b), mean: p => p.mu, variance: p => 2 * p.b ** 2, range: p => [p.mu - 6 * p.b, p.mu + 6 * p.b], sample: p => { const u = Math.random() - 0.5; return p.mu - p.b * Math.sign(u) * Math.log(1 - 2 * Math.abs(u)); } },
    logistic: { name: 'Logistic', category: 'Continuous', params: [{ id: 'mu', name: 'μ', min: -3, max: 3, step: 0.1, default: 0 }, { id: 's', name: 's', min: 0.1, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=e^(-(x-μ)/s)/(s(1+e^(-(x-μ)/s))²)', pdf: (x, p) => { const z = Math.exp(-(x - p.mu) / p.s); return z / (p.s * (1 + z) ** 2); }, cdf: (x, p) => 1 / (1 + Math.exp(-(x - p.mu) / p.s)), mean: p => p.mu, variance: p => (p.s ** 2 * Math.PI ** 2) / 3, range: p => [p.mu - 8 * p.s, p.mu + 8 * p.s], sample: p => { const u = Math.random(); return p.mu + p.s * Math.log(u / (1 - u)); } },
    gumbel: { name: 'Gumbel', category: 'Continuous', params: [{ id: 'mu', name: 'μ', min: -3, max: 3, step: 0.1, default: 0 }, { id: 'beta', name: 'β', min: 0.1, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=(1/β)e^(-(z+e^(-z)))', pdf: (x, p) => { const z = (x - p.mu) / p.beta; return Math.exp(-(z + Math.exp(-z))) / p.beta; }, cdf: (x, p) => Math.exp(-Math.exp(-(x - p.mu) / p.beta)), mean: p => p.mu + 0.5772 * p.beta, variance: p => (Math.PI ** 2 * p.beta ** 2) / 6, range: p => [p.mu - 4 * p.beta, p.mu + 6 * p.beta], sample: p => p.mu - p.beta * Math.log(-Math.log(Math.random())) },
    frechet: { name: 'Fréchet', category: 'Continuous', params: [{ id: 'alpha', name: 'α', min: 1, max: 5, step: 0.1, default: 2 }, { id: 's', name: 's', min: 0.5, max: 3, step: 0.1, default: 1 }, { id: 'm', name: 'm', min: 0, max: 3, step: 0.1, default: 0 }], formula: 'f(x)=(α/s)((x-m)/s)^(-1-α)e^(-((x-m)/s)^(-α))', pdf: (x, p) => { if (x <= p.m) return 0; const z = (x - p.m) / p.s; return (p.alpha / p.s) * Math.pow(z, -1 - p.alpha) * Math.exp(-Math.pow(z, -p.alpha)); }, cdf: (x, p) => x <= p.m ? 0 : Math.exp(-Math.pow((x - p.m) / p.s, -p.alpha)), mean: p => p.alpha > 1 ? p.m + p.s * gammaFn(1 - 1 / p.alpha) : Infinity, variance: p => p.alpha > 2 ? p.s ** 2 * (gammaFn(1 - 2 / p.alpha) - gammaFn(1 - 1 / p.alpha) ** 2) : Infinity, range: p => [p.m, p.m + 8 * p.s], sample: p => p.m + p.s * Math.pow(-Math.log(Math.random()), -1 / p.alpha) },
    rayleigh: { name: 'Rayleigh', category: 'Continuous', params: [{ id: 'sigma', name: 'σ', min: 0.1, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=(x/σ²)e^(-x²/2σ²)', pdf: (x, p) => x < 0 ? 0 : (x / (p.sigma ** 2)) * Math.exp(-x ** 2 / (2 * p.sigma ** 2)), cdf: (x, p) => x < 0 ? 0 : 1 - Math.exp(-x ** 2 / (2 * p.sigma ** 2)), mean: p => p.sigma * Math.sqrt(Math.PI / 2), variance: p => (4 - Math.PI) / 2 * p.sigma ** 2, range: () => [0, 6], sample: p => p.sigma * Math.sqrt(-2 * Math.log(Math.random())) },
    maxwell: { name: 'Maxwell-Boltzmann', category: 'Continuous', params: [{ id: 'a', name: 'a', min: 0.1, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=√(2/π)(x²/a³)e^(-x²/2a²)', pdf: (x, p) => x < 0 ? 0 : Math.sqrt(2 / Math.PI) * (x ** 2 / (p.a ** 3)) * Math.exp(-x ** 2 / (2 * p.a ** 2)), cdf: (x, p) => x < 0 ? 0 : erf(x / (p.a * Math.sqrt(2))) - Math.sqrt(2 / Math.PI) * (x / p.a) * Math.exp(-x ** 2 / (2 * p.a ** 2)), mean: p => 2 * p.a * Math.sqrt(2 / Math.PI), variance: p => p.a ** 2 * (3 * Math.PI - 8) / Math.PI, range: () => [0, 6], sample: p => Math.sqrt(normalSample() ** 2 + normalSample() ** 2 + normalSample() ** 2) * p.a },
    chi: { name: 'Chi', category: 'Continuous', params: [{ id: 'k', name: 'k', min: 1, max: 10, step: 1, default: 2 }], formula: 'f(x)=x^(k-1)e^(-x²/2)/(2^(k/2-1)Γ(k/2))', pdf: (x, p) => x < 0 ? 0 : (x ** (p.k - 1)) * Math.exp(-x ** 2 / 2) / (Math.pow(2, p.k / 2 - 1) * gammaFn(p.k / 2)), cdf: (x, p) => x < 0 ? 0 : incGamma(p.k / 2, x ** 2 / 2), mean: p => Math.sqrt(2) * gammaFn((p.k + 1) / 2) / gammaFn(p.k / 2), variance: p => p.k - DISTRIBUTIONS.chi.mean({ k: p.k }) ** 2, range: () => [0, 8], sample: p => { let s = 0; for (let i = 0; i < p.k; i++)s += normalSample() ** 2; return Math.sqrt(s); } },
    chisquared: { name: 'Chi-Squared', category: 'Continuous', params: [{ id: 'k', name: 'k', min: 1, max: 20, step: 1, default: 3 }], formula: 'f(x)=x^(k/2-1)e^(-x/2)/(2^(k/2)Γ(k/2))', pdf: (x, p) => x <= 0 ? 0 : (x ** (p.k / 2 - 1)) * Math.exp(-x / 2) / (Math.pow(2, p.k / 2) * gammaFn(p.k / 2)), cdf: (x, p) => x <= 0 ? 0 : incGamma(p.k / 2, x / 2), mean: p => p.k, variance: p => 2 * p.k, range: p => [0, Math.max(10, p.k + 4 * Math.sqrt(2 * p.k))], sample: p => 2 * gammaSample(p.k / 2) },
    studentt: { name: "Student's t", category: 'Continuous', params: [{ id: 'nu', name: 'ν', min: 1, max: 30, step: 1, default: 5 }], formula: 'f(x)=Γ((ν+1)/2)/(√(νπ)Γ(ν/2))(1+x²/ν)^(-(ν+1)/2)', pdf: (x, p) => gammaFn((p.nu + 1) / 2) / (Math.sqrt(p.nu * Math.PI) * gammaFn(p.nu / 2)) * Math.pow(1 + x ** 2 / p.nu, -(p.nu + 1) / 2), cdf: (x, p) => { const t = p.nu / (p.nu + x ** 2); return x > 0 ? 1 - 0.5 * incBeta(t, p.nu / 2, 0.5) : 0.5 * incBeta(t, p.nu / 2, 0.5); }, mean: p => p.nu > 1 ? 0 : NaN, variance: p => p.nu > 2 ? p.nu / (p.nu - 2) : (p.nu > 1 ? Infinity : NaN), range: () => [-6, 6], sample: p => normalSample() / Math.sqrt(gammaSample(p.nu / 2) * 2 / p.nu) },
    f: { name: 'F', category: 'Continuous', params: [{ id: 'd1', name: 'd₁', min: 1, max: 20, step: 1, default: 5 }, { id: 'd2', name: 'd₂', min: 1, max: 20, step: 1, default: 10 }], formula: 'f(x)=√((d1x)^d1×d2^d2/(d1x+d2)^(d1+d2))/(xB(d1/2,d2/2))', pdf: (x, p) => x <= 0 ? 0 : Math.sqrt(Math.pow(p.d1 * x, p.d1) * Math.pow(p.d2, p.d2) / Math.pow(p.d1 * x + p.d2, p.d1 + p.d2)) / (x * betaFn(p.d1 / 2, p.d2 / 2)), cdf: (x, p) => x <= 0 ? 0 : incBeta(p.d1 * x / (p.d1 * x + p.d2), p.d1 / 2, p.d2 / 2), mean: p => p.d2 > 2 ? p.d2 / (p.d2 - 2) : NaN, variance: p => p.d2 > 4 ? 2 * p.d2 ** 2 * (p.d1 + p.d2 - 2) / (p.d1 * (p.d2 - 2) ** 2 * (p.d2 - 4)) : NaN, range: () => [0, 6], sample: p => (gammaSample(p.d1 / 2) / p.d1) / (gammaSample(p.d2 / 2) / p.d2) },
    triangular: { name: 'Triangular', category: 'Continuous', params: [{ id: 'a', name: 'a', min: -3, max: 0, step: 0.1, default: -1 }, { id: 'b', name: 'b', min: 0, max: 5, step: 0.1, default: 3 }, { id: 'c', name: 'c', min: -1, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=2(x-a)/((b-a)(c-a)) if a≤x≤c', pdf: (x, p) => { if (x < p.a || x > p.b) return 0; if (x < p.c) return 2 * (x - p.a) / ((p.b - p.a) * (p.c - p.a)); if (x === p.c) return 2 / (p.b - p.a); return 2 * (p.b - x) / ((p.b - p.a) * (p.b - p.c)); }, cdf: (x, p) => { if (x <= p.a) return 0; if (x >= p.b) return 1; if (x <= p.c) return (x - p.a) ** 2 / ((p.b - p.a) * (p.c - p.a)); return 1 - (p.b - x) ** 2 / ((p.b - p.a) * (p.b - p.c)); }, mean: p => (p.a + p.b + p.c) / 3, variance: p => (p.a ** 2 + p.b ** 2 + p.c ** 2 - p.a * p.b - p.a * p.c - p.b * p.c) / 18, range: p => [p.a - 0.5, p.b + 0.5], sample: p => { const u = Math.random(), fc = (p.c - p.a) / (p.b - p.a); return u < fc ? p.a + Math.sqrt(u * (p.b - p.a) * (p.c - p.a)) : p.b - Math.sqrt((1 - u) * (p.b - p.a) * (p.b - p.c)); } },
    pert: { name: 'PERT', category: 'Continuous', params: [{ id: 'a', name: 'a', min: -3, max: 0, step: 0.1, default: 0 }, { id: 'b', name: 'b', min: 1, max: 6, step: 0.1, default: 4 }, { id: 'c', name: 'c', min: 0, max: 4, step: 0.1, default: 2 }], formula: 'f(x)∝(x-a)^(α-1)(b-x)^(β-1)', pdf: (x, p) => { if (x < p.a || x > p.b) return 0; const mu = (p.a + 4 * p.c + p.b) / 6; const alpha = 1 + 4 * (mu - p.a) / (p.b - p.a); const beta_ = 1 + 4 * (p.b - mu) / (p.b - p.a); return ((x - p.a) ** (alpha - 1)) * ((p.b - x) ** (beta_ - 1)) / ((p.b - p.a) ** (alpha + beta_ - 1) * betaFn(alpha, beta_)); }, cdf: (x, p) => { if (x <= p.a) return 0; if (x >= p.b) return 1; const mu = (p.a + 4 * p.c + p.b) / 6; const alpha = 1 + 4 * (mu - p.a) / (p.b - p.a); const beta_ = 1 + 4 * (p.b - mu) / (p.b - p.a); return incBeta((x - p.a) / (p.b - p.a), alpha, beta_); }, mean: p => (p.a + 4 * p.c + p.b) / 6, variance: p => ((p.b - p.a) ** 2) / 36, range: p => [p.a - 0.5, p.b + 0.5], sample: p => { const mu = (p.a + 4 * p.c + p.b) / 6; const alpha = 1 + 4 * (mu - p.a) / (p.b - p.a); const beta_ = 1 + 4 * (p.b - mu) / (p.b - p.a); const x = gammaSample(alpha), y = gammaSample(beta_); return p.a + (p.b - p.a) * x / (x + y); } },
    vonmises: { name: 'von Mises', category: 'Continuous', params: [{ id: 'mu', name: 'μ', min: -3.14, max: 3.14, step: 0.1, default: 0 }, { id: 'kappa', name: 'κ', min: 0.1, max: 5, step: 0.1, default: 2 }], formula: 'f(θ)=e^(κcos(θ-μ))/(2πI₀(κ))', pdf: (x, p) => { const i0 = besselI0(p.kappa); return Math.exp(p.kappa * Math.cos(x - p.mu)) / (2 * Math.PI * i0); }, cdf: (x, p) => { let sum = 0; for (let t = -Math.PI; t <= x; t += 0.01)sum += DISTRIBUTIONS.vonmises.pdf(t, p) * 0.01; return sum; }, mean: p => p.mu, variance: p => 1 - besselI1(p.kappa) / besselI0(p.kappa), range: () => [-Math.PI, Math.PI], sample: p => { const tau = 1 + Math.sqrt(1 + 4 * p.kappa ** 2); const rho = (tau - Math.sqrt(2 * tau)) / (2 * p.kappa); const r = (1 + rho ** 2) / (2 * rho); while (true) { const u1 = Math.random(), u2 = Math.random(); const z = Math.cos(Math.PI * u1); const f = (1 + r * z) / (r + z); const c = p.kappa * (r - f); if (c * (2 - c) > u2 || Math.log(c / u2) + 1 >= c) { const u3 = Math.random(); return u3 > 0.5 ? Math.acos(f) + p.mu : -Math.acos(f) + p.mu; } } } },
    semicircle: { name: 'Semicircle (Wigner)', category: 'Continuous', params: [{ id: 'R', name: 'R', min: 0.5, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=(2/πR²)√(R²-x²)', pdf: (x, p) => Math.abs(x) >= p.R ? 0 : (2 / (Math.PI * p.R ** 2)) * Math.sqrt(p.R ** 2 - x ** 2), cdf: (x, p) => { if (x <= -p.R) return 0; if (x >= p.R) return 1; return 0.5 + (x * Math.sqrt(p.R ** 2 - x ** 2) + p.R ** 2 * Math.asin(x / p.R)) / (Math.PI * p.R ** 2); }, mean: () => 0, variance: p => p.R ** 2 / 4, range: p => [-p.R - 0.5, p.R + 0.5], sample: p => { while (true) { const x = (2 * Math.random() - 1) * p.R; const y = Math.random() * 2 / (Math.PI * p.R); if (y < DISTRIBUTIONS.semicircle.pdf(x, p)) return x; } } },
    arcsine: { name: 'Arcsine', category: 'Continuous', params: [{ id: 'a', name: 'a', min: 0, max: 0.5, step: 0.1, default: 0 }, { id: 'b', name: 'b', min: 0.5, max: 2, step: 0.1, default: 1 }], formula: 'f(x)=1/(π√((x-a)(b-x)))', pdf: (x, p) => (x <= p.a || x >= p.b) ? 0 : 1 / (Math.PI * Math.sqrt((x - p.a) * (p.b - x))), cdf: (x, p) => { if (x <= p.a) return 0; if (x >= p.b) return 1; return (2 / Math.PI) * Math.asin(Math.sqrt((x - p.a) / (p.b - p.a))); }, mean: p => (p.a + p.b) / 2, variance: p => (p.b - p.a) ** 2 / 8, range: p => [p.a, p.b], sample: p => { const u = Math.random(); return p.a + (p.b - p.a) * Math.sin(Math.PI * u / 2) ** 2; } },
    kumaraswamy: { name: 'Kumaraswamy', category: 'Continuous', params: [{ id: 'a', name: 'a', min: 0.1, max: 5, step: 0.1, default: 2 }, { id: 'b', name: 'b', min: 0.1, max: 5, step: 0.1, default: 5 }], formula: 'f(x)=abx^(a-1)(1-x^a)^(b-1)', pdf: (x, p) => (x <= 0 || x >= 1) ? 0 : p.a * p.b * (x ** (p.a - 1)) * ((1 - x ** p.a) ** (p.b - 1)), cdf: (x, p) => { if (x <= 0) return 0; if (x >= 1) return 1; return 1 - (1 - x ** p.a) ** p.b; }, mean: p => p.b * gammaFn(1 + 1 / p.a) * gammaFn(p.b) / gammaFn(1 + 1 / p.a + p.b), variance: p => { const m1 = p.b * gammaFn(1 + 1 / p.a) * gammaFn(p.b) / gammaFn(1 + 1 / p.a + p.b); const m2 = p.b * gammaFn(1 + 2 / p.a) * gammaFn(p.b) / gammaFn(1 + 2 / p.a + p.b); return m2 - m1 ** 2; }, range: () => [0, 1], sample: p => Math.pow(1 - Math.pow(1 - Math.random(), 1 / p.b), 1 / p.a) },
    levy: { name: 'Lévy', category: 'Continuous', params: [{ id: 'mu', name: 'μ', min: -2, max: 2, step: 0.1, default: 0 }, { id: 'c', name: 'c', min: 0.1, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=√(c/2π)(e^(-c/2(x-μ)))/(x-μ)^(3/2)', pdf: (x, p) => x <= p.mu ? 0 : Math.sqrt(p.c / (2 * Math.PI)) * Math.exp(-p.c / (2 * (x - p.mu))) / ((x - p.mu) ** 1.5), cdf: (x, p) => x <= p.mu ? 0 : 1 - erf(Math.sqrt(p.c / (2 * (x - p.mu)))), mean: () => Infinity, variance: () => Infinity, range: p => [p.mu, p.mu + 10], sample: p => { const n = normalSample(); return p.mu + p.c / (n ** 2); } },
    erlang: { name: 'Erlang', category: 'Continuous', params: [{ id: 'k', name: 'k', min: 1, max: 10, step: 1, default: 3 }, { id: 'lambda', name: 'λ', min: 0.1, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=λ^k x^(k-1)e^(-λx)/(k-1)!', pdf: (x, p) => x < 0 ? 0 : (p.lambda ** p.k) * (x ** (p.k - 1)) * Math.exp(-p.lambda * x) / factorial(p.k - 1), cdf: (x, p) => x < 0 ? 0 : incGamma(p.k, p.lambda * x), mean: p => p.k / p.lambda, variance: p => p.k / (p.lambda ** 2), range: p => [0, (p.k + 4 * Math.sqrt(p.k)) / p.lambda], sample: p => { let s = 0; for (let i = 0; i < p.k; i++)s -= Math.log(Math.random()); return s / p.lambda; } },
    inversegamma: { name: 'Inverse Gamma', category: 'Continuous', params: [{ id: 'alpha', name: 'α', min: 1, max: 5, step: 0.1, default: 2 }, { id: 'beta', name: 'β', min: 0.5, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=(β^α/Γ(α))x^(-α-1)e^(-β/x)', pdf: (x, p) => x <= 0 ? 0 : (p.beta ** p.alpha / gammaFn(p.alpha)) * (x ** (-p.alpha - 1)) * Math.exp(-p.beta / x), cdf: (x, p) => x <= 0 ? 0 : 1 - incGamma(p.alpha, p.beta / x), mean: p => p.alpha > 1 ? p.beta / (p.alpha - 1) : Infinity, variance: p => p.alpha > 2 ? p.beta ** 2 / ((p.alpha - 1) ** 2 * (p.alpha - 2)) : Infinity, range: () => [0.01, 8], sample: p => p.beta / gammaSample(p.alpha) },
    inversegaussian: { name: 'Inverse Gaussian', category: 'Continuous', params: [{ id: 'mu', name: 'μ', min: 0.5, max: 3, step: 0.1, default: 1 }, { id: 'lambda', name: 'λ', min: 0.5, max: 5, step: 0.1, default: 1 }], formula: 'f(x)=√(λ/2πx³)e^(-λ(x-μ)²/2μ²x)', pdf: (x, p) => x <= 0 ? 0 : Math.sqrt(p.lambda / (2 * Math.PI * x ** 3)) * Math.exp(-p.lambda * (x - p.mu) ** 2 / (2 * p.mu ** 2 * x)), cdf: (x, p) => { if (x <= 0) return 0; const phi1 = 0.5 * (1 + erf((Math.sqrt(p.lambda / x) * (x / p.mu - 1)) / Math.sqrt(2))); const phi2 = 0.5 * (1 + erf((-Math.sqrt(p.lambda / x) * (x / p.mu + 1)) / Math.sqrt(2))); return phi1 + Math.exp(2 * p.lambda / p.mu) * phi2; }, mean: p => p.mu, variance: p => p.mu ** 3 / p.lambda, range: p => [0, p.mu * 4], sample: p => { const y = normalSample() ** 2; const x = p.mu + p.mu ** 2 * y / (2 * p.lambda) - p.mu / (2 * p.lambda) * Math.sqrt(4 * p.mu * p.lambda * y + p.mu ** 2 * y ** 2); return Math.random() < p.mu / (p.mu + x) ? x : p.mu ** 2 / x; } },
    lomax: { name: 'Lomax (Pareto II)', category: 'Continuous', params: [{ id: 'alpha', name: 'α', min: 1, max: 5, step: 0.1, default: 2 }, { id: 'lambda', name: 'λ', min: 0.5, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=(α/λ)(1+x/λ)^(-α-1)', pdf: (x, p) => x < 0 ? 0 : (p.alpha / p.lambda) * Math.pow(1 + x / p.lambda, -p.alpha - 1), cdf: (x, p) => x < 0 ? 0 : 1 - Math.pow(1 + x / p.lambda, -p.alpha), mean: p => p.alpha > 1 ? p.lambda / (p.alpha - 1) : Infinity, variance: p => p.alpha > 2 ? p.lambda ** 2 * p.alpha / ((p.alpha - 1) ** 2 * (p.alpha - 2)) : Infinity, range: () => [0, 10], sample: p => p.lambda * (Math.pow(Math.random(), -1 / p.alpha) - 1) },
    betaprime: { name: 'Beta Prime', category: 'Continuous', params: [{ id: 'alpha', name: 'α', min: 0.5, max: 5, step: 0.1, default: 2 }, { id: 'beta', name: 'β', min: 0.5, max: 5, step: 0.1, default: 3 }], formula: 'f(x)=x^(α-1)(1+x)^(-α-β)/B(α,β)', pdf: (x, p) => x <= 0 ? 0 : (x ** (p.alpha - 1)) * Math.pow(1 + x, -p.alpha - p.beta) / betaFn(p.alpha, p.beta), cdf: (x, p) => x <= 0 ? 0 : incBeta(x / (1 + x), p.alpha, p.beta), mean: p => p.beta > 1 ? p.alpha / (p.beta - 1) : Infinity, variance: p => p.beta > 2 ? p.alpha * (p.alpha + p.beta - 1) / ((p.beta - 2) * (p.beta - 1) ** 2) : Infinity, range: () => [0, 8], sample: p => { const x = gammaSample(p.alpha), y = gammaSample(p.beta); return x / y; } },
    // Discrete distributions
    binomial: { name: 'Binomial', category: 'Discrete', discrete: true, params: [{ id: 'n', name: 'n', min: 1, max: 50, step: 1, default: 10 }, { id: 'p', name: 'p', min: 0.01, max: 0.99, step: 0.01, default: 0.5 }], formula: 'P(X=k)=C(n,k)p^k(1-p)^(n-k)', pdf: (k, p) => { k = Math.round(k); if (k < 0 || k > p.n) return 0; return binomial(p.n, k) * (p.p ** k) * ((1 - p.p) ** (p.n - k)); }, cdf: (k, p) => { let sum = 0; for (let i = 0; i <= Math.floor(k); i++)sum += DISTRIBUTIONS.binomial.pdf(i, p); return sum; }, mean: p => p.n * p.p, variance: p => p.n * p.p * (1 - p.p), range: p => [0, p.n], sample: p => { let s = 0; for (let i = 0; i < p.n; i++)if (Math.random() < p.p) s++; return s; } },
    poisson: { name: 'Poisson', category: 'Discrete', discrete: true, params: [{ id: 'lambda', name: 'λ', min: 0.1, max: 20, step: 0.1, default: 5 }], formula: 'P(X=k)=(λ^k e^(-λ))/k!', pdf: (k, p) => { k = Math.round(k); if (k < 0) return 0; return (p.lambda ** k) * Math.exp(-p.lambda) / factorial(k); }, cdf: (k, p) => { let sum = 0; for (let i = 0; i <= Math.floor(k); i++)sum += DISTRIBUTIONS.poisson.pdf(i, p); return sum; }, mean: p => p.lambda, variance: p => p.lambda, range: p => [0, Math.max(20, p.lambda * 3)], sample: p => { let L = Math.exp(-p.lambda), k = 0, pp = 1; do { k++; pp *= Math.random(); } while (pp > L); return k - 1; } },
    geometric: { name: 'Geometric', category: 'Discrete', discrete: true, params: [{ id: 'p', name: 'p', min: 0.01, max: 0.99, step: 0.01, default: 0.3 }], formula: 'P(X=k)=(1-p)^(k-1)p', pdf: (k, p) => { k = Math.round(k); if (k < 1) return 0; return ((1 - p.p) ** (k - 1)) * p.p; }, cdf: (k, p) => { if (k < 1) return 0; return 1 - (1 - p.p) ** Math.floor(k); }, mean: p => 1 / p.p, variance: p => (1 - p.p) / (p.p ** 2), range: () => [1, 20], sample: p => Math.ceil(Math.log(Math.random()) / Math.log(1 - p.p)) },
    negativebinomial: { name: 'Negative Binomial', category: 'Discrete', discrete: true, params: [{ id: 'r', name: 'r', min: 1, max: 10, step: 1, default: 3 }, { id: 'p', name: 'p', min: 0.1, max: 0.9, step: 0.01, default: 0.5 }], formula: 'P(X=k)=C(k+r-1,k)p^r(1-p)^k', pdf: (k, p) => { k = Math.round(k); if (k < 0) return 0; return binomial(k + p.r - 1, k) * (p.p ** p.r) * ((1 - p.p) ** k); }, cdf: (k, p) => { let sum = 0; for (let i = 0; i <= Math.floor(k); i++)sum += DISTRIBUTIONS.negativebinomial.pdf(i, p); return sum; }, mean: p => p.r * (1 - p.p) / p.p, variance: p => p.r * (1 - p.p) / (p.p ** 2), range: p => [0, Math.max(20, p.r * 3)], sample: p => { let s = 0; for (let i = 0; i < p.r; i++)s += Math.floor(Math.log(Math.random()) / Math.log(1 - p.p)); return s; } },
    hypergeometric: { name: 'Hypergeometric', category: 'Discrete', discrete: true, params: [{ id: 'N', name: 'N', min: 10, max: 100, step: 1, default: 50 }, { id: 'K', name: 'K', min: 1, max: 50, step: 1, default: 20 }, { id: 'n', name: 'n', min: 1, max: 30, step: 1, default: 10 }], formula: 'P(X=k)=C(K,k)C(N-K,n-k)/C(N,n)', pdf: (k, p) => { k = Math.round(k); const low = Math.max(0, p.n - p.N + p.K), high = Math.min(p.K, p.n); if (k < low || k > high) return 0; return binomial(p.K, k) * binomial(p.N - p.K, p.n - k) / binomial(p.N, p.n); }, cdf: (k, p) => { let sum = 0; const low = Math.max(0, p.n - p.N + p.K); for (let i = low; i <= Math.floor(k); i++)sum += DISTRIBUTIONS.hypergeometric.pdf(i, p); return sum; }, mean: p => p.n * p.K / p.N, variance: p => p.n * p.K * (p.N - p.K) * (p.N - p.n) / (p.N ** 2 * (p.N - 1)), range: p => [Math.max(0, p.n - p.N + p.K), Math.min(p.K, p.n)], sample: p => { let s = 0, K = p.K, N = p.N; for (let i = 0; i < p.n; i++) { if (Math.random() < K / N) { s++; K--; } N--; } return s; } },
    bernoulli: { name: 'Bernoulli', category: 'Discrete', discrete: true, params: [{ id: 'p', name: 'p', min: 0, max: 1, step: 0.01, default: 0.5 }], formula: 'P(X=k)=p^k(1-p)^(1-k)', pdf: (k, p) => { k = Math.round(k); if (k === 0) return 1 - p.p; if (k === 1) return p.p; return 0; }, cdf: (k, p) => { if (k < 0) return 0; if (k < 1) return 1 - p.p; return 1; }, mean: p => p.p, variance: p => p.p * (1 - p.p), range: () => [0, 1], sample: p => Math.random() < p.p ? 1 : 0 },
    discreteuniform: { name: 'Discrete Uniform', category: 'Discrete', discrete: true, params: [{ id: 'a', name: 'a', min: 0, max: 5, step: 1, default: 1 }, { id: 'b', name: 'b', min: 5, max: 20, step: 1, default: 10 }], formula: 'P(X=k)=1/(b-a+1)', pdf: (k, p) => { k = Math.round(k); if (k < p.a || k > p.b) return 0; return 1 / (p.b - p.a + 1); }, cdf: (k, p) => { if (k < p.a) return 0; if (k >= p.b) return 1; return (Math.floor(k) - p.a + 1) / (p.b - p.a + 1); }, mean: p => (p.a + p.b) / 2, variance: p => ((p.b - p.a + 1) ** 2 - 1) / 12, range: p => [p.a, p.b], sample: p => Math.floor(Math.random() * (p.b - p.a + 1)) + p.a },
    zipf: { name: 'Zipf', category: 'Discrete', discrete: true, params: [{ id: 's', name: 's', min: 1, max: 3, step: 0.1, default: 1 }, { id: 'N', name: 'N', min: 5, max: 50, step: 1, default: 20 }], formula: 'P(X=k)=(1/k^s)/H(N,s)', pdf: (k, p) => { k = Math.round(k); if (k < 1 || k > p.N) return 0; let H = 0; for (let i = 1; i <= p.N; i++)H += 1 / Math.pow(i, p.s); return (1 / Math.pow(k, p.s)) / H; }, cdf: (k, p) => { if (k < 1) return 0; let sum = 0; for (let i = 1; i <= Math.min(Math.floor(k), p.N); i++)sum += DISTRIBUTIONS.zipf.pdf(i, p); return sum; }, mean: p => { let H1 = 0, H0 = 0; for (let i = 1; i <= p.N; i++) { H0 += 1 / Math.pow(i, p.s); H1 += 1 / Math.pow(i, p.s - 1); } return H1 / H0; }, variance: p => { let H0 = 0, H1 = 0, H2 = 0; for (let i = 1; i <= p.N; i++) { H0 += 1 / Math.pow(i, p.s); H1 += 1 / Math.pow(i, p.s - 1); H2 += 1 / Math.pow(i, p.s - 2); } const mu = H1 / H0; return H2 / H0 - mu ** 2; }, range: p => [1, p.N], sample: p => { const u = Math.random(); let sum = 0; for (let i = 1; i <= p.N; i++) { sum += DISTRIBUTIONS.zipf.pdf(i, p); if (u <= sum) return i; } return p.N; } },
    logarithmic: { name: 'Logarithmic', category: 'Discrete', discrete: true, params: [{ id: 'p', name: 'p', min: 0.1, max: 0.99, step: 0.01, default: 0.5 }], formula: 'P(X=k)=-p^k/(k·ln(1-p))', pdf: (k, pa) => { k = Math.round(k); if (k < 1) return 0; return -Math.pow(pa.p, k) / (k * Math.log(1 - pa.p)); }, cdf: (k, pa) => { let sum = 0; for (let i = 1; i <= Math.floor(k); i++)sum += DISTRIBUTIONS.logarithmic.pdf(i, pa); return sum; }, mean: p => -p.p / ((1 - p.p) * Math.log(1 - p.p)), variance: p => { const q = 1 - p.p; return -p.p * (p.p + Math.log(q)) / (q ** 2 * Math.log(q) ** 2); }, range: () => [1, 20], sample: p => { const u = Math.random(); let sum = 0; for (let k = 1; k <= 100; k++) { sum += DISTRIBUTIONS.logarithmic.pdf(k, p); if (u <= sum) return k; } return 1; } },
    yulesimon: { name: 'Yule-Simon', category: 'Discrete', discrete: true, params: [{ id: 'rho', name: 'ρ', min: 1, max: 5, step: 0.1, default: 2 }], formula: 'P(X=k)=ρB(k,ρ+1)', pdf: (k, p) => { k = Math.round(k); if (k < 1) return 0; return p.rho * betaFn(k, p.rho + 1); }, cdf: (k, p) => { let sum = 0; for (let i = 1; i <= Math.floor(k); i++)sum += DISTRIBUTIONS.yulesimon.pdf(i, p); return sum; }, mean: p => p.rho > 1 ? p.rho / (p.rho - 1) : Infinity, variance: p => p.rho > 2 ? p.rho ** 2 / ((p.rho - 1) ** 2 * (p.rho - 2)) : Infinity, range: () => [1, 20], sample: p => { const e = gammaSample(1); const g = gammaSample(p.rho); let k = 1; while (Math.random() > g / (g + k * e)) k++; return k; } },
    zeta: { name: 'Zeta (Zipf)', category: 'Discrete', discrete: true, params: [{ id: 's', name: 's', min: 1.01, max: 4, step: 0.01, default: 2 }], formula: 'P(X=k)=1/(k^s·ζ(s))', pdf: (k, p) => { k = Math.round(k); if (k < 1) return 0; let zeta = 0; for (let i = 1; i <= 1000; i++)zeta += 1 / Math.pow(i, p.s); return 1 / (Math.pow(k, p.s) * zeta); }, cdf: (k, p) => { let sum = 0; for (let i = 1; i <= Math.floor(k); i++)sum += DISTRIBUTIONS.zeta.pdf(i, p); return sum; }, mean: p => { if (p.s <= 2) return Infinity; let zeta = 0, zeta1 = 0; for (let i = 1; i <= 1000; i++) { zeta += 1 / Math.pow(i, p.s); zeta1 += 1 / Math.pow(i, p.s - 1); } return zeta1 / zeta; }, variance: p => { if (p.s <= 3) return Infinity; let z0 = 0, z1 = 0, z2 = 0; for (let i = 1; i <= 1000; i++) { z0 += 1 / Math.pow(i, p.s); z1 += 1 / Math.pow(i, p.s - 1); z2 += 1 / Math.pow(i, p.s - 2); } return z2 / z0 - (z1 / z0) ** 2; }, range: () => [1, 20], sample: p => { const u = Math.random(); let sum = 0; for (let k = 1; k <= 1000; k++) { sum += DISTRIBUTIONS.zeta.pdf(k, p); if (u <= sum) return k; } return 1; } },
    // Special distributions
    halfnormal: { name: 'Half-Normal', category: 'Special', params: [{ id: 'sigma', name: 'σ', min: 0.1, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=(√2/σ√π)e^(-x²/2σ²)', pdf: (x, p) => x < 0 ? 0 : (Math.sqrt(2 / Math.PI) / p.sigma) * Math.exp(-x ** 2 / (2 * p.sigma ** 2)), cdf: (x, p) => x < 0 ? 0 : erf(x / (p.sigma * Math.sqrt(2))), mean: p => p.sigma * Math.sqrt(2 / Math.PI), variance: p => p.sigma ** 2 * (1 - 2 / Math.PI), range: () => [0, 6], sample: p => Math.abs(p.sigma * normalSample()) },
    foldednormal: { name: 'Folded Normal', category: 'Special', params: [{ id: 'mu', name: 'μ', min: 0, max: 3, step: 0.1, default: 1 }, { id: 'sigma', name: 'σ', min: 0.1, max: 2, step: 0.1, default: 1 }], formula: 'f(x)=φ((x-μ)/σ)+φ((x+μ)/σ)', pdf: (x, p) => { if (x < 0) return 0; const phi = z => Math.exp(-z ** 2 / 2) / Math.sqrt(2 * Math.PI); return (phi((x - p.mu) / p.sigma) + phi((x + p.mu) / p.sigma)) / p.sigma; }, cdf: (x, p) => { if (x < 0) return 0; return 0.5 * (erf((x + p.mu) / (p.sigma * Math.sqrt(2))) + erf((x - p.mu) / (p.sigma * Math.sqrt(2)))); }, mean: p => p.sigma * Math.sqrt(2 / Math.PI) * Math.exp(-p.mu ** 2 / (2 * p.sigma ** 2)) + p.mu * (1 - 2 * 0.5 * (1 - erf(p.mu / (p.sigma * Math.sqrt(2))))), variance: p => p.mu ** 2 + p.sigma ** 2 - DISTRIBUTIONS.foldednormal.mean(p) ** 2, range: () => [0, 8], sample: p => Math.abs(p.mu + p.sigma * normalSample()) },
    truncatednormal: { name: 'Truncated Normal', category: 'Special', params: [{ id: 'mu', name: 'μ', min: -2, max: 2, step: 0.1, default: 0 }, { id: 'sigma', name: 'σ', min: 0.1, max: 2, step: 0.1, default: 1 }, { id: 'a', name: 'a', min: -4, max: 0, step: 0.1, default: -2 }, { id: 'b', name: 'b', min: 0, max: 4, step: 0.1, default: 2 }], formula: 'f(x)=φ((x-μ)/σ)/(σ(Φ(β)-Φ(α)))', pdf: (x, p) => { if (x < p.a || x > p.b) return 0; const phi = z => Math.exp(-z ** 2 / 2) / Math.sqrt(2 * Math.PI); const Phi = z => 0.5 * (1 + erf(z / Math.sqrt(2))); const alpha = (p.a - p.mu) / p.sigma, beta_ = (p.b - p.mu) / p.sigma; const Z = Phi(beta_) - Phi(alpha); return phi((x - p.mu) / p.sigma) / (p.sigma * Z); }, cdf: (x, p) => { if (x < p.a) return 0; if (x > p.b) return 1; const Phi = z => 0.5 * (1 + erf(z / Math.sqrt(2))); const alpha = (p.a - p.mu) / p.sigma, beta_ = (p.b - p.mu) / p.sigma; return (Phi((x - p.mu) / p.sigma) - Phi(alpha)) / (Phi(beta_) - Phi(alpha)); }, mean: p => { const phi = z => Math.exp(-z ** 2 / 2) / Math.sqrt(2 * Math.PI); const Phi = z => 0.5 * (1 + erf(z / Math.sqrt(2))); const alpha = (p.a - p.mu) / p.sigma, beta_ = (p.b - p.mu) / p.sigma; return p.mu + p.sigma * (phi(alpha) - phi(beta_)) / (Phi(beta_) - Phi(alpha)); }, variance: p => { const phi = z => Math.exp(-z ** 2 / 2) / Math.sqrt(2 * Math.PI); const Phi = z => 0.5 * (1 + erf(z / Math.sqrt(2))); const alpha = (p.a - p.mu) / p.sigma, beta_ = (p.b - p.mu) / p.sigma; const Z = Phi(beta_) - Phi(alpha); return p.sigma ** 2 * (1 + (alpha * phi(alpha) - beta_ * phi(beta_)) / Z - ((phi(alpha) - phi(beta_)) / Z) ** 2); }, range: p => [p.a, p.b], sample: p => { const Phi = z => 0.5 * (1 + erf(z / Math.sqrt(2))); const PhiInv = u => { let low = -8, high = 8; while (high - low > 1e-10) { const mid = (low + high) / 2; if (Phi(mid) < u) low = mid; else high = mid; } return low; }; const alpha = (p.a - p.mu) / p.sigma, beta_ = (p.b - p.mu) / p.sigma; const u = Phi(alpha) + Math.random() * (Phi(beta_) - Phi(alpha)); return p.mu + p.sigma * PhiInv(u); } },
    power: { name: 'Power', category: 'Special', params: [{ id: 'alpha', name: 'α', min: 0.1, max: 5, step: 0.1, default: 2 }], formula: 'f(x)=αx^(α-1)', pdf: (x, p) => (x < 0 || x > 1) ? 0 : p.alpha * Math.pow(x, p.alpha - 1), cdf: (x, p) => { if (x < 0) return 0; if (x > 1) return 1; return Math.pow(x, p.alpha); }, mean: p => p.alpha / (p.alpha + 1), variance: p => p.alpha / ((p.alpha + 1) ** 2 * (p.alpha + 2)), range: () => [0, 1], sample: p => Math.pow(Math.random(), 1 / p.alpha) },
    bradford: { name: 'Bradford', category: 'Special', params: [{ id: 'c', name: 'c', min: 0.1, max: 5, step: 0.1, default: 2 }], formula: 'f(x)=c/(ln(1+c)(1+cx))', pdf: (x, p) => (x < 0 || x > 1) ? 0 : p.c / (Math.log(1 + p.c) * (1 + p.c * x)), cdf: (x, p) => { if (x < 0) return 0; if (x > 1) return 1; return Math.log(1 + p.c * x) / Math.log(1 + p.c); }, mean: p => (p.c - Math.log(1 + p.c)) / (p.c * Math.log(1 + p.c)), variance: p => { const k = Math.log(1 + p.c); return ((p.c + 2) * k - 2 * p.c) / (2 * p.c * k ** 2); }, range: () => [0, 1], sample: p => (Math.pow(1 + p.c, Math.random()) - 1) / p.c },
    reciprocal: { name: 'Reciprocal (Log-Uniform)', category: 'Special', params: [{ id: 'a', name: 'a', min: 0.1, max: 1, step: 0.1, default: 0.5 }, { id: 'b', name: 'b', min: 1, max: 10, step: 0.1, default: 5 }], formula: 'f(x)=1/(x·ln(b/a))', pdf: (x, p) => (x < p.a || x > p.b) ? 0 : 1 / (x * Math.log(p.b / p.a)), cdf: (x, p) => { if (x < p.a) return 0; if (x > p.b) return 1; return Math.log(x / p.a) / Math.log(p.b / p.a); }, mean: p => (p.b - p.a) / Math.log(p.b / p.a), variance: p => { const L = Math.log(p.b / p.a); return (p.b ** 2 - p.a ** 2) / (2 * L) - ((p.b - p.a) / L) ** 2; }, range: p => [p.a, p.b], sample: p => p.a * Math.pow(p.b / p.a, Math.random()) },
    cosine: { name: 'Raised Cosine', category: 'Special', params: [{ id: 'mu', name: 'μ', min: -3, max: 3, step: 0.1, default: 0 }, { id: 's', name: 's', min: 0.5, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=(1/2s)(1+cos(π(x-μ)/s))', pdf: (x, p) => { const y = (x - p.mu) / p.s; if (Math.abs(y) > 1) return 0; return (1 + Math.cos(Math.PI * y)) / (2 * p.s); }, cdf: (x, p) => { if (x < p.mu - p.s) return 0; if (x > p.mu + p.s) return 1; const y = (x - p.mu) / p.s; return 0.5 * (1 + y + Math.sin(Math.PI * y) / Math.PI); }, mean: p => p.mu, variance: p => p.s ** 2 * (1 / 3 - 2 / (Math.PI ** 2)), range: p => [p.mu - p.s - 0.5, p.mu + p.s + 0.5], sample: p => { while (true) { const x = p.mu + (2 * Math.random() - 1) * p.s; const y = Math.random() / (p.s); if (y < DISTRIBUTIONS.cosine.pdf(x, p)) return x; } } },
    generalizedexponential: { name: 'Generalized Exponential', category: 'Special', params: [{ id: 'alpha', name: 'α', min: 0.5, max: 5, step: 0.1, default: 2 }, { id: 'lambda', name: 'λ', min: 0.1, max: 3, step: 0.1, default: 1 }], formula: 'f(x)=αλ(1-e^(-λx))^(α-1)e^(-λx)', pdf: (x, p) => x < 0 ? 0 : p.alpha * p.lambda * Math.pow(1 - Math.exp(-p.lambda * x), p.alpha - 1) * Math.exp(-p.lambda * x), cdf: (x, p) => x < 0 ? 0 : Math.pow(1 - Math.exp(-p.lambda * x), p.alpha), mean: p => { let sum = 0; for (let k = 0; k < 20; k++)sum += Math.pow(-1, k) * binomial(p.alpha, k + 1) / (k + 1); return sum / p.lambda; }, variance: p => { const m1 = DISTRIBUTIONS.generalizedexponential.mean(p); let sum = 0; for (let k = 0; k < 20; k++)sum += Math.pow(-1, k) * binomial(p.alpha, k + 1) / (k + 1) ** 2; return 2 * sum / (p.lambda ** 2) - m1 ** 2; }, range: () => [0, 8], sample: p => -Math.log(1 - Math.pow(Math.random(), 1 / p.alpha)) / p.lambda },
};

// Bessel functions for von Mises
function besselI0(x) { let sum = 1, term = 1; for (let k = 1; k <= 20; k++) { term *= (x / 2) ** 2 / (k * k); sum += term; } return sum; }
function besselI1(x) { let sum = x / 2, term = x / 2; for (let k = 1; k <= 20; k++) { term *= (x / 2) ** 2 / (k * (k + 1)); sum += term; } return sum; }

